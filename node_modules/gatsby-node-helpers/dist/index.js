'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _crypto = require('crypto');

var _fp = require('lodash/fp');

var _pIsPromise = require('p-is-promise');

var _pIsPromise2 = _interopRequireDefault(_pIsPromise);

var _jsonStringifySafe = require('json-stringify-safe');

var _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default parent ID for all nodes.
const DEFAULT_PARENT_ID = `__SOURCE__`;

// Node fields used internally by Gatsby.
const RESTRICTED_NODE_FIELDS = [`id`, `children`, `parent`, `fields`, `internal`];

// Generates an MD5 hash from a string.
const digest = str => (0, _crypto.createHash)(`md5`).update(str).digest(`hex`);

// Generates an MD5 hash of an object and assign it to the internal.contentDigest key.
const withDigest = obj => (0, _fp.assoc)([`internal`, `contentDigest`], digest((0, _jsonStringifySafe2.default)(obj)), obj);

// Returns node helpers for creating new nodes.
const createNodeHelpers = (options = {}) => {
  if (!(0, _fp.isPlainObject)(options)) throw new Error(`Options must be an object. An argument of type ${typeof options} was provided.`);

  if (typeof options.sourceId !== `undefined` && typeof options.sourceId !== `string`) throw new Error(`options.sourceId must be a string. A value of type ${typeof options.sourceId} was provided.`);

  if (typeof options.typePrefix !== `string`) throw new Error(`options.typePrefix must be a string. A value of type ${typeof options.typePrefix} was provided.`);

  if (typeof options.conflictFieldPrefix !== `undefined` && typeof options.conflictFieldPrefix !== `string`) throw new Error(`options.conflictFieldPrefix must be a string. A value of type ${typeof options.conflictFieldPrefix} was provided.`);

  const {
    sourceId = DEFAULT_PARENT_ID,
    typePrefix,
    conflictFieldPrefix = (0, _fp.lowerFirst)(typePrefix)
  } = options;

  // Generates a node ID from a given type and node ID.
  const generateNodeId = (type, id) => `${typePrefix}__${(0, _fp.upperFirst)((0, _fp.camelCase)(type))}__${id}`;

  // Generates a node type name from a given type.
  const generateTypeName = type => (0, _fp.upperFirst)((0, _fp.camelCase)(`${typePrefix} ${type}`));

  // Prefixes conflicting node fields.
  const prefixConflictingKeys = obj => {
    Object.keys(obj).forEach(key => {
      if (RESTRICTED_NODE_FIELDS.includes(key)) {
        obj[conflictFieldPrefix + (0, _fp.upperFirst)(key)] = obj[key];
        delete obj[key];
      }
    });

    return obj;
  };

  // Creates a node factory with a given type and middleware processor.
  const createNodeFactory = (type, middleware = _fp.identity) => (obj, overrides = {}) => {
    // if (!isPlainObject(obj))
    //   throw new Error(
    //     `The source object must be a plain object. An argument of type "${typeof obj}" was provided.`,
    //   )

    // if (!isPlainObject(overrides))
    //   throw new Error(
    //     `Node overrides must be a plain object. An argument of type "${typeof overrides}" was provided.`,
    //   )

    const clonedObj = (0, _fp.cloneDeep)(obj);
    const safeObj = prefixConflictingKeys(clonedObj);

    let node = _extends({}, safeObj, {
      id: generateNodeId(type, obj.id),
      parent: sourceId,
      children: [],
      internal: {
        type: generateTypeName(type)
      }
    });

    node = middleware(node);

    if ((0, _pIsPromise2.default)(node)) return node.then(resolvedNode => withDigest(_extends({}, resolvedNode, overrides)));

    return withDigest(_extends({}, node, overrides));
  };

  return {
    createNodeFactory,
    generateNodeId,
    generateTypeName
  };
};

exports.default = createNodeHelpers;